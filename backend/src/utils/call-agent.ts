import type { MessageTextContent } from "@azure/ai-agents";
import { AgentsClient, isOutputOfType } from "@azure/ai-agents";
import { DefaultAzureCredential } from "@azure/identity";

import "dotenv/config";
import { AgentId, getAgentId } from "../types/agents";

const projectEndpoint = process.env.AZURE_AI_FOUNDRY_ENDPOINT || "";

if (!projectEndpoint) {
  throw new Error("AZURE_AI_FOUNDRY_ENDPOINT environment variable is not set.");
}

export async function callAgent(agentId: AgentId, userString: string): Promise<string> {
  // Create an Azure AI Client
  const azureAgentId = getAgentId(agentId);
  const client = new AgentsClient(projectEndpoint, new DefaultAzureCredential());

  // Create a thread
  const thread = await client.threads.create();
  console.log(`Created thread, thread ID: ${thread.id}`);

  // Create a message
  const message = await client.messages.create(thread.id, "user", userString);
  console.log(`Created message, message ID: ${message.id}`);

  // Create and execute a run
  const run = await client.runs.create(thread.id, azureAgentId);
  console.log(`Created run, run ID: ${run.id}`);

  // Wait for the run to complete
  let runStatus = run.status;
  while (runStatus === "queued" || runStatus === "in_progress") {
    console.log(`Run status: ${runStatus}, waiting...`);
    await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds
    
    const updatedRun = await client.runs.get(thread.id, run.id);
    runStatus = updatedRun.status;
    
    if (runStatus === "failed" || runStatus === "cancelled") {
      throw new Error(`Run failed with status: ${runStatus}`);
    }
  }
  
  console.log(`Run completed with status: ${runStatus}`);

  // Get messages after run completion
  const messagesIterator = client.messages.list(thread.id);
  const messagesArray = [];
  for await (const m of messagesIterator) {
    messagesArray.push(m);
  }
  console.log("Messages:", messagesArray);

  // If no assistant response yet, wait a bit more and try again
  const assistantMessages = messagesArray.filter(m => m.role === "assistant");
  if (assistantMessages.length === 0 || assistantMessages.every(m => !m.content || m.content.length === 0)) {
    console.log("No assistant response yet, waiting a bit more...");
    await new Promise(resolve => setTimeout(resolve, 3000)); // Wait 3 more seconds
    
    const messagesIterator2 = client.messages.list(thread.id);
    const messagesArray2 = [];
    for await (const m of messagesIterator2) {
      messagesArray2.push(m);
    }
    console.log("Updated Messages:", messagesArray2);
    
    // Use the updated messages
    messagesArray.length = 0; // Clear the array
    messagesArray.push(...messagesArray2);
  }

  // Iterate through messages and extract assistant responses
  let response = "";

  console.log(`File Paths:`);
  console.log(`Message Details:`);
  
  // Process messages in reverse order to get the latest assistant response
  const reversedMessages = [...messagesArray].reverse();
  
  for (const m of reversedMessages) {
    if (m.role === "assistant") {
      console.log(`Processing assistant message: ${m.id}`);
      
      // Check if message has content and if the first content item exists
      if (m.content && m.content.length > 0 && m.content[0]) {
        console.log(`Content type: ${m.content[0].type}`);
        if (isOutputOfType<MessageTextContent>(m.content[0], "text")) {
          const textContent = m.content[0] as MessageTextContent;
          const textValue = textContent.text?.value || "";
          console.log(`Text content: ${textValue.substring(0, 100)}...`);
          response += textValue;
          break; // Use the first (most recent) assistant message with content
        }
      } else {
        console.log(`Assistant message ${m.id} has no content or empty content array`);
      }
    }
  }

  if (!response) {
    console.log("No assistant response found with text content");
    return "No response generated by the agent.";
  }

  return response;
}
